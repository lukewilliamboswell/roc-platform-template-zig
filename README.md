
This is an exploration for the new design for calling into roc.

## Demo

```sh
$ zig build-obj host/app.zig
$ zig build-lib host/main.zig
$ zig build-exe app.o libmain.a
$ ./app
info: Running Roc APP
Hello
```

## Overview

In this demo, the platform host is implemented in [host/main.zig](host/main.zig).

It is using the types and functions from [host/glue.zig](host/glue.zig) which in future would be generated by the roc compiler using something like `roc glue ZigGlue.roc src/ platform/main.roc`.

The other side, the roc (app), is simulated by the [host/app.zig](host/app.zig) file. This is what the roc compiler would code gen.

## Notes

Roc will generate low-level functions for working with all of the primitive types that are exposed for a program. For example you can the see `extern` symbols below which help working with roc strings.

```
extern fn roc__str_len(out: *u64, str: *RocStr) void;
extern fn roc__str_ptr(out: *?[*]u8, str: *RocStr) void;
```

This is then made easier to work with using the `roc glue` subcommand which takes a glue plugin `ZigGlue.roc` and a source directory `src/` and generates the `glue.zig` file which includes higher level functions for working with the roc types.

```zig
pub const RocStr = extern struct {

    // included to ensure size and alignment is correct for internal representation
    a: usize,
    b: usize,
    c: usize,

    pub fn asSlice(self: *RocStr) []const u8 {
        /// ...
    }

    pub fn fromSlice(effects: *PlatformEffects, slice: []const u8) RocStr {
        /// ...
    }
}
```

**TODO** - explain convention of ordering function args and return type

```zig
// 1. (if required) pointer to effects struct
// 2. (if required) pointer to return value
// 3. (if required) pointer to each arg
extern fn roc__str_new(effects: *PlatformEffects, out: *RocStr, data: [*]const u8, len: *const u64) void;
```

**TODO** - explain the `PlatformEffects` struct and how it is used

```zig
pub const PlatformEffects = extern struct {
    // 1. DATA STORE
    // store any state for the host, ie. the allocator might be required by an effect
    data: *anyopaque,

    // 2. ROC ALLOCATORS (in alphabetical order)

    // Allocators for roc to use
    roc_alloc: *const fn (effects: *PlatformEffects, size: usize, alignment: u32) callconv(.C) ?*anyopaque,
    roc_dealloc: *const fn (effects: *PlatformEffects, c_ptr: *anyopaque, alignment: u32) callconv(.C) void,
    roc_realloc: *const fn (effects: *PlatformEffects, c_ptr: *anyopaque, new_size: usize, old_size: usize, alignment: u32) callconv(.C) ?*anyopaque,

    // 3. ROC OTHER (in alphabetical order)

    // `dbg` was called
    roc_dbg: *const fn (effects: *PlatformEffects, loc: *RocStr, msg: *RocStr, src: *RocStr) callconv(.C) void,

    // `roc test` was ran and an expect failed, or an inline `expect` assertion failed
    roc_expect_failed: *const fn (effects: *PlatformEffects, loc: *RocStr, src: *RocStr, variables: *anyopaque) callconv(.C) void,

    // roc crashed in an unrecoverable way
    roc_panic: *const fn (effects: *PlatformEffects, msg: *RocStr, tag_id: u32) callconv(.C) void,

    // 4. PLATFORM EFFECTS (in alphabetical order)

    // the stdin_line! effect
    stdin_line: *const fn (effects: *PlatformEffects, ret: *RocStr) callconv(.C) void,
    // the stdout_line! effect
    stdout_line: *const fn (effects: *PlatformEffects, msg: *RocStr) callconv(.C) void,
};
```

**TODO** - explain how the entrpoints work

```zig
// symbols implemented by roc in the `app.o` object file
pub extern fn roc__init_for_host(
    // 1. struct of function pointers
    effects: *const PlatformEffects,
    // 2. pointer for roc to write the return data
    out: *RocStr,
) callconv(.C) void;

pub extern fn roc__run_for_host(
    // 1. struct of function pointers
    effects: *const PlatformEffects,
    // 2. pointer for roc to write the return data
    out: *i32,
    // 3. pointer to each argument
    state: *RocStr,
) callconv(.C) void;
```
