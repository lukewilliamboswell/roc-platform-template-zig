
This is an exploration for the new design for calling into roc.

## Demo

```sh
$ zig build-exe app.o libmain.a
$ zig build-lib host/main.zig
$ zig build-exe app.o libmain.a
$ ./app
info: Running Roc APP
Hello
```

## Overview

In this demo, the platform host is implemented in [host/main.zig](host/main.zig).

It is using the types and functions from [host/glue.zig](host/glue.zig) which in future would be generated by the roc compiler using something like `roc glue ZigGlue.roc src/ platform/main.roc`.

The other side, the roc (app), is simulated by the [app/main.zig](app/main.zig) file. This is what the roc compiler would code gen.

## Notes

Roc will generate low-level functions for working with all of the primitive types that are exposed for a program. For example you can the see `extern` symbols below which help working with roc strings.

```
extern fn roc__str_len(out: *u64, str: *RocStr) void;
extern fn roc__str_ptr(out: *?[*]u8, str: *RocStr) void;
```

This is then made easier to work with using the `roc glue` subcommand which takes a glue plugin `ZigGlue.roc` and a source directory `src/` and generates the `glue.zig` file which includes higher level functions for working with the roc types.

```zig
pub const RocStr = extern struct {

    // included to ensure size and alignment is correct for internal representation
    a: usize,
    b: usize,
    c: usize,

    pub fn asSlice(self: *RocStr) []const u8 {
        /// ...
    }

    pub fn fromSlice(effects: *PlatformEffects, slice: []const u8) RocStr {
        /// ...
    }
}
```
