<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Command Buffer Round-Trip Test</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            margin: 20px;
            background: #1a1a2e;
            color: #e0e0e0;
        }
        h1 {
            color: #fff;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }
        #results {
            background: #2a2a3e;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            max-height: 400px;
            overflow-y: auto;
        }
        .pass {
            color: #4caf50;
        }
        .fail {
            color: #f44336;
        }
        .info {
            color: #2196f3;
        }
        .section {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #444;
        }
        canvas {
            border: 2px solid #444;
            border-radius: 5px;
            display: block;
            margin-top: 20px;
        }
        #expected {
            margin-top: 20px;
            padding: 15px;
            background: #2a2a3e;
            border-radius: 5px;
        }
        #expected h3 {
            margin-top: 0;
            color: #fff;
        }
        #expected ul {
            margin: 0;
            padding-left: 20px;
        }
    </style>
</head>
<body>
    <h1>Command Buffer Round-Trip Test</h1>
    <div id="results"></div>
    <canvas id="canvas" width="500" height="300"></canvas>
    <div id="expected">
        <h3>Expected Visual Output:</h3>
        <ul>
            <li>Blue background (clear color)</li>
            <li>Red rectangle at (10, 10), size 100x50</li>
            <li>Green circle at (200, 100), radius 30</li>
            <li>Yellow line from (300, 10) to (400, 100)</li>
            <li>White text "Test" at (10, 200), size 32px</li>
        </ul>
    </div>

    <script>
        'use strict';

        // Color palette (must match Zig)
        const COLORS = [
            '#000000', '#0000ff', '#505050', '#808080', '#00ff00',
            '#c0c0c0', '#ffa500', '#ffc0cb', '#800080', '#f5f5f5',
            '#ff0000', '#ffffff', '#ffff00'
        ];
        const CMD_RECT = 1, CMD_CIRCLE = 2, CMD_LINE = 3, CMD_TEXT = 4;
        const MAX_COMMANDS = 2048, MAX_RECTS = 1024, MAX_CIRCLES = 512;
        const MAX_LINES = 512, MAX_TEXTS = 256, MAX_STRING_BYTES = 8192;

        const results = document.getElementById('results');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const decoder = new TextDecoder();

        let passCount = 0;
        let failCount = 0;

        function log(msg, type = 'info') {
            const div = document.createElement('div');
            div.className = type;
            const prefix = type === 'pass' ? '✓ ' : (type === 'fail' ? '✗ ' : '• ');
            div.textContent = prefix + msg;
            results.appendChild(div);

            if (type === 'pass') passCount++;
            if (type === 'fail') failCount++;

            return type !== 'fail';
        }

        function assert(condition, msg) {
            return log(msg, condition ? 'pass' : 'fail');
        }

        function section(name) {
            const div = document.createElement('div');
            div.className = 'section';
            div.innerHTML = `<strong>${name}</strong>`;
            results.appendChild(div);
        }

        async function runTests() {
            log('Loading WASM module...');

            let wasm, memory, OFFSETS, cmdBufferPtr;

            try {
                const response = await fetch('host_web.wasm');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                // Provide stub implementations for Roc functions
                // These are imported by host_web.zig but not used for testing
                const imports = {
                    env: {
                        // Stub for roc__init_for_host - does nothing
                        roc__init_for_host: function(ops, ret, arg) {},
                        // Stub for roc__render_for_host - does nothing
                        roc__render_for_host: function(ops, ret, args) {},
                    }
                };

                const { instance } = await WebAssembly.instantiateStreaming(response, imports);
                wasm = instance.exports;
                memory = wasm.memory;
                log('WASM loaded successfully', 'pass');
            } catch (e) {
                log(`Failed to load WASM: ${e.message}`, 'fail');
                return;
            }

            // Get buffer pointer and offsets
            section('Buffer Setup');
            cmdBufferPtr = wasm._get_cmd_buffer_ptr();
            log(`Command buffer pointer: 0x${cmdBufferPtr.toString(16)}`);

            OFFSETS = {
                has_clear: wasm._get_offset_has_clear(),
                clear_color: wasm._get_offset_clear_color(),
                cmd_stream: wasm._get_offset_cmd_stream(),
                cmd_count: wasm._get_offset_cmd_count(),
                rect_count: wasm._get_offset_rect_count(),
                rect_x: wasm._get_offset_rect_x(),
                rect_y: wasm._get_offset_rect_y(),
                rect_w: wasm._get_offset_rect_w(),
                rect_h: wasm._get_offset_rect_h(),
                rect_color: wasm._get_offset_rect_color(),
                circle_count: wasm._get_offset_circle_count(),
                circle_x: wasm._get_offset_circle_x(),
                circle_y: wasm._get_offset_circle_y(),
                circle_radius: wasm._get_offset_circle_radius(),
                circle_color: wasm._get_offset_circle_color(),
                line_count: wasm._get_offset_line_count(),
                line_x1: wasm._get_offset_line_x1(),
                line_y1: wasm._get_offset_line_y1(),
                line_x2: wasm._get_offset_line_x2(),
                line_y2: wasm._get_offset_line_y2(),
                line_color: wasm._get_offset_line_color(),
                text_count: wasm._get_offset_text_count(),
                text_x: wasm._get_offset_text_x(),
                text_y: wasm._get_offset_text_y(),
                text_size: wasm._get_offset_text_size(),
                text_color: wasm._get_offset_text_color(),
                text_str_offset: wasm._get_offset_text_str_offset(),
                text_str_len: wasm._get_offset_text_str_len(),
                string_buffer: wasm._get_offset_string_buffer(),
                string_buffer_len: wasm._get_offset_string_buffer_len(),
            };

            assert(cmdBufferPtr > 0, `Buffer pointer is valid (${cmdBufferPtr})`);
            assert(OFFSETS.cmd_stream > 0, `cmd_stream offset is valid (${OFFSETS.cmd_stream})`);

            // Run test function
            section('Test Draw Commands');
            const cmdCount = wasm._test_draw_commands();
            assert(cmdCount === 4, `_test_draw_commands returned ${cmdCount} commands (expected 4)`);

            // Read buffer values
            section('Buffer Validation');
            const view = new DataView(memory.buffer, cmdBufferPtr);
            const base = cmdBufferPtr;

            // Check clear
            const hasClear = view.getUint8(OFFSETS.has_clear) !== 0;
            assert(hasClear === true, `has_clear = ${hasClear}`);

            const clearColor = view.getUint8(OFFSETS.clear_color);
            assert(clearColor === 1, `clear_color = ${clearColor} (expected 1 for Blue)`);

            // Check cmd_count
            const readCmdCount = view.getUint32(OFFSETS.cmd_count, true);
            assert(readCmdCount === 4, `cmd_count = ${readCmdCount} (expected 4)`);

            // Check rectangle
            const rectCount = view.getUint32(OFFSETS.rect_count, true);
            assert(rectCount === 1, `rect_count = ${rectCount} (expected 1)`);

            const rectX = new Float32Array(memory.buffer, base + OFFSETS.rect_x, MAX_RECTS);
            const rectY = new Float32Array(memory.buffer, base + OFFSETS.rect_y, MAX_RECTS);
            const rectW = new Float32Array(memory.buffer, base + OFFSETS.rect_w, MAX_RECTS);
            const rectH = new Float32Array(memory.buffer, base + OFFSETS.rect_h, MAX_RECTS);
            const rectColor = new Uint8Array(memory.buffer, base + OFFSETS.rect_color, MAX_RECTS);

            assert(rectX[0] === 10, `rect_x[0] = ${rectX[0]} (expected 10)`);
            assert(rectY[0] === 10, `rect_y[0] = ${rectY[0]} (expected 10)`);
            assert(rectW[0] === 100, `rect_w[0] = ${rectW[0]} (expected 100)`);
            assert(rectH[0] === 50, `rect_h[0] = ${rectH[0]} (expected 50)`);
            assert(rectColor[0] === 10, `rect_color[0] = ${rectColor[0]} (expected 10 for Red)`);

            // Check circle
            const circleCount = view.getUint32(OFFSETS.circle_count, true);
            assert(circleCount === 1, `circle_count = ${circleCount} (expected 1)`);

            const circleX = new Float32Array(memory.buffer, base + OFFSETS.circle_x, MAX_CIRCLES);
            const circleY = new Float32Array(memory.buffer, base + OFFSETS.circle_y, MAX_CIRCLES);
            const circleRadius = new Float32Array(memory.buffer, base + OFFSETS.circle_radius, MAX_CIRCLES);
            const circleColor = new Uint8Array(memory.buffer, base + OFFSETS.circle_color, MAX_CIRCLES);

            assert(circleX[0] === 200, `circle_x[0] = ${circleX[0]} (expected 200)`);
            assert(circleY[0] === 100, `circle_y[0] = ${circleY[0]} (expected 100)`);
            assert(circleRadius[0] === 30, `circle_radius[0] = ${circleRadius[0]} (expected 30)`);
            assert(circleColor[0] === 4, `circle_color[0] = ${circleColor[0]} (expected 4 for Green)`);

            // Check line
            const lineCount = view.getUint32(OFFSETS.line_count, true);
            assert(lineCount === 1, `line_count = ${lineCount} (expected 1)`);

            const lineX1 = new Float32Array(memory.buffer, base + OFFSETS.line_x1, MAX_LINES);
            const lineY1 = new Float32Array(memory.buffer, base + OFFSETS.line_y1, MAX_LINES);
            const lineX2 = new Float32Array(memory.buffer, base + OFFSETS.line_x2, MAX_LINES);
            const lineY2 = new Float32Array(memory.buffer, base + OFFSETS.line_y2, MAX_LINES);
            const lineColorArr = new Uint8Array(memory.buffer, base + OFFSETS.line_color, MAX_LINES);

            assert(lineX1[0] === 300, `line_x1[0] = ${lineX1[0]} (expected 300)`);
            assert(lineY1[0] === 10, `line_y1[0] = ${lineY1[0]} (expected 10)`);
            assert(lineX2[0] === 400, `line_x2[0] = ${lineX2[0]} (expected 400)`);
            assert(lineY2[0] === 100, `line_y2[0] = ${lineY2[0]} (expected 100)`);
            assert(lineColorArr[0] === 12, `line_color[0] = ${lineColorArr[0]} (expected 12 for Yellow)`);

            // Check text
            const textCount = view.getUint32(OFFSETS.text_count, true);
            assert(textCount === 1, `text_count = ${textCount} (expected 1)`);

            const textXArr = new Float32Array(memory.buffer, base + OFFSETS.text_x, MAX_TEXTS);
            const textYArr = new Float32Array(memory.buffer, base + OFFSETS.text_y, MAX_TEXTS);
            const textSizeArr = new Int32Array(memory.buffer, base + OFFSETS.text_size, MAX_TEXTS);
            const textColorArr = new Uint8Array(memory.buffer, base + OFFSETS.text_color, MAX_TEXTS);
            const textStrOffsetArr = new Uint16Array(memory.buffer, base + OFFSETS.text_str_offset, MAX_TEXTS);
            const textStrLenArr = new Uint16Array(memory.buffer, base + OFFSETS.text_str_len, MAX_TEXTS);
            const stringBuffer = new Uint8Array(memory.buffer, base + OFFSETS.string_buffer, MAX_STRING_BYTES);

            assert(textXArr[0] === 10, `text_x[0] = ${textXArr[0]} (expected 10)`);
            assert(textYArr[0] === 200, `text_y[0] = ${textYArr[0]} (expected 200)`);
            assert(textSizeArr[0] === 32, `text_size[0] = ${textSizeArr[0]} (expected 32)`);
            assert(textColorArr[0] === 11, `text_color[0] = ${textColorArr[0]} (expected 11 for White)`);

            const strOff = textStrOffsetArr[0];
            const strLen = textStrLenArr[0];
            const textStr = decoder.decode(stringBuffer.subarray(strOff, strOff + strLen));
            assert(textStr === 'Test', `text string = "${textStr}" (expected "Test")`);

            // Verify command stream order
            section('Command Stream');
            const cmdStream = new Uint16Array(memory.buffer, base + OFFSETS.cmd_stream, MAX_COMMANDS);

            const cmd0Type = cmdStream[0] >> 12;
            const cmd0Idx = cmdStream[0] & 0xFFF;
            assert(cmd0Type === CMD_RECT && cmd0Idx === 0, `cmd[0] = rect[0] (type=${cmd0Type}, idx=${cmd0Idx})`);

            const cmd1Type = cmdStream[1] >> 12;
            const cmd1Idx = cmdStream[1] & 0xFFF;
            assert(cmd1Type === CMD_CIRCLE && cmd1Idx === 0, `cmd[1] = circle[0] (type=${cmd1Type}, idx=${cmd1Idx})`);

            const cmd2Type = cmdStream[2] >> 12;
            const cmd2Idx = cmdStream[2] & 0xFFF;
            assert(cmd2Type === CMD_LINE && cmd2Idx === 0, `cmd[2] = line[0] (type=${cmd2Type}, idx=${cmd2Idx})`);

            const cmd3Type = cmdStream[3] >> 12;
            const cmd3Idx = cmdStream[3] & 0xFFF;
            assert(cmd3Type === CMD_TEXT && cmd3Idx === 0, `cmd[3] = text[0] (type=${cmd3Type}, idx=${cmd3Idx})`);

            // Visual render
            section('Visual Rendering');
            if (failCount === 0) {
                renderTestOutput(view, OFFSETS, cmdStream, readCmdCount, {
                    rectX, rectY, rectW, rectH, rectColor,
                    circleX, circleY, circleRadius, circleColor,
                    lineX1, lineY1, lineX2, lineY2, lineColor: lineColorArr,
                    textXArr, textYArr, textSizeArr, textColorArr,
                    textStrOffsetArr, textStrLenArr, stringBuffer
                });
                log('Visual render complete - verify canvas matches expected output', 'pass');
            } else {
                log('Skipping visual render due to earlier failures', 'fail');
            }

            // Summary
            section('Summary');
            if (failCount === 0) {
                log(`ALL ${passCount} TESTS PASSED`, 'pass');
            } else {
                log(`${failCount} TESTS FAILED, ${passCount} passed`, 'fail');
            }
        }

        function renderTestOutput(view, OFFSETS, cmdStream, cmdCount, arrays) {
            // Clear with blue
            if (view.getUint8(OFFSETS.has_clear)) {
                const clearColor = view.getUint8(OFFSETS.clear_color);
                ctx.fillStyle = COLORS[clearColor];
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Render commands in order
            for (let c = 0; c < cmdCount; c++) {
                const cmd = cmdStream[c];
                const type = cmd >> 12;
                const idx = cmd & 0xFFF;

                switch (type) {
                    case CMD_RECT:
                        ctx.fillStyle = COLORS[arrays.rectColor[idx]];
                        ctx.fillRect(arrays.rectX[idx], arrays.rectY[idx], arrays.rectW[idx], arrays.rectH[idx]);
                        break;

                    case CMD_CIRCLE:
                        ctx.fillStyle = COLORS[arrays.circleColor[idx]];
                        ctx.beginPath();
                        ctx.arc(arrays.circleX[idx], arrays.circleY[idx], arrays.circleRadius[idx], 0, Math.PI * 2);
                        ctx.fill();
                        break;

                    case CMD_LINE:
                        ctx.strokeStyle = COLORS[arrays.lineColor[idx]];
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(arrays.lineX1[idx], arrays.lineY1[idx]);
                        ctx.lineTo(arrays.lineX2[idx], arrays.lineY2[idx]);
                        ctx.stroke();
                        break;

                    case CMD_TEXT:
                        ctx.fillStyle = COLORS[arrays.textColorArr[idx]];
                        ctx.font = `${arrays.textSizeArr[idx]}px sans-serif`;
                        const strOff = arrays.textStrOffsetArr[idx];
                        const strLen = arrays.textStrLenArr[idx];
                        const str = decoder.decode(arrays.stringBuffer.subarray(strOff, strOff + strLen));
                        ctx.fillText(str, arrays.textXArr[idx], arrays.textYArr[idx]);
                        break;
                }
            }
        }

        // Run tests on load
        runTests().catch(e => log(`Uncaught error: ${e.message}`, 'fail'));
    </script>
</body>
</html>
